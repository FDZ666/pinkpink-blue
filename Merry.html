<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ„ åŠ¨æ€åœ£è¯æ ‘</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            background: linear-gradient(to bottom, #00111f, #000814);
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        #canvas-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            height: 80vh;
        }

        canvas {
            display: block;
            margin: 0 auto;
        }

        .message {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 14px;
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.7);
        }
    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="christmasTreeCanvas"></canvas>
        <div class="message">ğŸ„ åœ£è¯å¿«ä¹ï¼ğŸ„</div>
    </div>

    <script>
        // --- é…ç½® ---
        const TREE_COLOR = '#00a651'; // æ ‘çš„ç»¿è‰²
        const TRUNK_COLOR = '#8B4513'; // æ ‘å¹²æ£•è‰²
        const STAR_COLOR = '#FFD700'; // æ˜Ÿæ˜Ÿé‡‘è‰²
        const LIGHT_COLORS = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff']; // å½©ç¯é¢œè‰²
        const NUM_LIGHTS = 60; // å½©ç¯æ•°é‡
        const SNOWFLAKES_COUNT = 100; // é›ªèŠ±æ•°é‡

        // --- åˆå§‹åŒ– ---
        const canvas = document.getElementById('christmasTreeCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        function resizeCanvas() {
            width = canvas.width = canvas.clientWidth;
            height = canvas.height = canvas.clientHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); // åˆå§‹è®¾ç½®

        // --- åœ£è¯æ ‘ç»˜åˆ¶å‡½æ•° ---
        function drawTree() {
            ctx.clearRect(0, 0, width, height);

            // è®¡ç®—æ ‘çš„ä¸­å¿ƒä½ç½®å’Œå°ºå¯¸
            const centerX = width / 2;
            const treeHeight = height * 0.6;
            const trunkHeight = treeHeight * 0.15;
            const trunkWidth = treeHeight * 0.08;
            const starSize = trunkWidth * 1.5;

            // ç»˜åˆ¶æ ‘å¹²
            ctx.fillStyle = TRUNK_COLOR;
            ctx.fillRect(centerX - trunkWidth / 2, height - trunkHeight, trunkWidth, trunkHeight);

            // ç»˜åˆ¶ä¸‰å±‚æ ‘å† 
            const layerHeight = (treeHeight - trunkHeight) / 3;
            const drawLayer = (topY, widthFactor) => {
                const w = widthFactor * treeHeight;
                ctx.beginPath();
                ctx.moveTo(centerX, topY);
                ctx.lineTo(centerX - w / 2, topY + layerHeight);
                ctx.lineTo(centerX + w / 2, topY + layerHeight);
                ctx.closePath();
                ctx.fillStyle = TREE_COLOR;
                ctx.fill();
            };

            drawLayer(height - trunkHeight - layerHeight * 3, 0.8);
            drawLayer(height - trunkHeight - layerHeight * 2, 0.6);
            drawLayer(height - trunkHeight - layerHeight, 0.4);

            // ç»˜åˆ¶é¡¶éƒ¨æ˜Ÿæ˜Ÿ
            drawStar(centerX, height - trunkHeight - layerHeight * 3 - starSize / 2, starSize, 5, STAR_COLOR);
        }

        // ç»˜åˆ¶æ˜Ÿæ˜Ÿçš„è¾…åŠ©å‡½æ•°
        function drawStar(cx, cy, r, spikes, color) {
            let rot = Math.PI / 2 * 3;
            let x = cx;
            let y = cy;
            let step = Math.PI / spikes;

            ctx.beginPath();
            ctx.moveTo(cx, cy - r);

            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * r;
                y = cy + Math.sin(rot) * r;
                ctx.lineTo(x, y);
                rot += step;

                x = cx + Math.cos(rot) * r / 2;
                y = cy + Math.sin(rot) * r / 2;
                ctx.lineTo(x, y);
                rot += step;
            }

            ctx.lineTo(cx, cy - r);
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
        }

        // --- å½©ç¯ç³»ç»Ÿ ---
        let lights = [];

        function initializeLights() {
            lights = [];
            const treeArea = {
                top: height * 0.1,
                bottom: height * 0.85,
                left: width * 0.3,
                right: width * 0.7
            };

            for (let i = 0; i < NUM_LIGHTS; i++) {
                lights.push({
                    x: Math.random() * (treeArea.right - treeArea.left) + treeArea.left,
                    y: Math.random() * (treeArea.bottom - treeArea.top) + treeArea.top,
                    color: LIGHT_COLORS[Math.floor(Math.random() * LIGHT_COLORS.length)],
                    on: Math.random() > 0.5, // åˆå§‹çŠ¶æ€
                    blinkSpeed: Math.random() * 0.05 + 0.02, // é—ªçƒé€Ÿåº¦
                    phase: Math.random() * Math.PI * 2 // é—ªçƒç›¸ä½
                });
            }
        }

        function drawLights() {
            lights.forEach(light => {
                if (light.on) {
                    ctx.beginPath();
                    ctx.arc(light.x, light.y, 5, 0, Math.PI * 2);
                    ctx.fillStyle = light.color;
                    ctx.fill();

                    // æ·»åŠ å‘å…‰æ•ˆæœ
                    const gradient = ctx.createRadialGradient(light.x, light.y, 2, light.x, light.y, 10);
                    gradient.addColorStop(0, light.color);
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(light.x, light.y, 10, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        function updateLights() {
            const time = Date.now() / 1000;
            lights.forEach(light => {
                // ä½¿ç”¨æ­£å¼¦æ³¢å‡½æ•°è®©ç¯å…‰å¹³æ»‘åœ°äº®ç­
                light.on = Math.sin(time * light.blinkSpeed + light.phase) > 0.2;
            });
        }

        // --- é›ªèŠ±ç³»ç»Ÿ ---
        let snowflakes = [];

        function initializeSnowflakes() {
            snowflakes = [];
            for (let i = 0; i < SNOWFLAKES_COUNT; i++) {
                snowflakes.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    radius: Math.random() * 3 + 1,
                    speed: Math.random() * 1 + 0.5,
                    sway: Math.random() * 0.5 - 0.25, // æ°´å¹³æ‘†åŠ¨é€Ÿåº¦
                    swayOffset: Math.random() * Math.PI * 2 // æ‘†åŠ¨ç›¸ä½
                });
            }
        }

        function drawSnowflakes() {
            ctx.fillStyle = 'white';
            snowflakes.forEach(flake => {
                ctx.beginPath();
                ctx.arc(flake.x, flake.y, flake.radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function updateSnowflakes() {
            snowflakes.forEach(flake => {
                flake.y += flake.speed;
                flake.x += Math.sin(Date.now() / 1000 * flake.sway + flake.swayOffset) * 0.5;

                if (flake.y > height) {
                    flake.y = -10;
                    flake.x = Math.random() * width;
                }
            });
        }

        // --- ä¸»å¾ªç¯ ---
        function animate() {
            drawTree();
            updateLights();
            drawLights();
            updateSnowflakes();
            drawSnowflakes();
            requestAnimationFrame(animate);
        }

        // --- å¯åŠ¨ ---
        initializeLights();
        initializeSnowflakes();
        animate();

    </script>

</body>
</html>